## Python新式类和旧式类
### 新式类和旧式类
1. Python2默认是旧式类，只有继承object时候才是新式类
Python3只有新式类
2. Python2 type(classobj)=instance python3则不是
3. 新式类搜索属性是广度优先，旧式类搜索属性是深度优先
### type()和isinstance()
- type()不会认为子类是一种父类类型
- isinstance()认为子类是一种父类类型
- 

## 二叉树搜索
广度优先搜索，前序遍历（深度优先搜索），中序遍历，后序遍历
可以用递归的思想很容易实现
或者利用stack/queue的数据结构实现

## Python命名空间和作用域
- 命名空间 
	- 名字到对象的映射
	- 字典实现
	- 全局/局部(函数/类)/内建
	- 内建: abs(), max()...
- 命名空间的生命周期
	- 内置ns在解释器启动的时候创建，解释器退出的时候销毁
	- 全局ns在解释器读入模块的时候创建，解释器退出时销毁
	- 函数的局部命名空间，在函数调用时创建，函数返回或者由未捕获的异常时销毁；类定义的命名空间，在解释器读到类定义创建，类定义结束后销毁
- 作用域 
	- 作用域就是一段文本区域，这段区域中可以通过名字**直接访问**命名空间中的数据，
	- 作用域只是文本区域，其定义是静态的；而名字空间却是动态的，只有随着解释器的执行，命名空间才会产生。那么，在静态的作用域中访问动态命名空间中的名字，造成了作用域使用的动态性。静态的作用域，是一个或多个命名空间按照一定规则叠加影响代码区域；运行时动态的作用域，是按照特定层次组合起来的命名空间。
	- 内建/全局/闭包/局部, 先搜索Local->Enclosing->Global->Built-in
- 赋值(左值)操作只发生在当前作用域
- **命名空间**就**字典**
- **globals()**，**locals()**这两个方法是关于返回作用域的函数，前者返回全局作用域，后者返回当前的本地作用域
- 查看

## python闭包
本身是一个函数，由函数和闭包作用域中的自由变量组成
这个函数一般就是函数中的函数，外函数中的局部变量被内函数使用后，外函数再返回内函数，该局部变量再脱离外函数之后，还可以在函数之外被访问到
目的是避免使用全局变量
闭包函数的\_\_closure\_\_属性返回cell元组对象，cell对象中的cell_contents就是闭包作用域中的自由变量

```
def createCount():
	a = 0
	def counter():
		nonlocal a
		a=a+1
		return a
	return counter
```

```
def outer():
	funs = []
	for i in range(3):
		def inner():
			return i*i
		funs.append(inner)
	return funs
f1, f2, f3 = outer()
```

## python Enum
```
def enumerate(seq, start=0):
	n = start
	for i in seq:
		yield n, i
	n += 1
```
```
from enum import Enum, unique, auto
class Fruits(Enum):
    APPLE = auto()
    PEAR = auto()
    WATERMELON = auto()
    BANANA = auto()
print(Fruits.APPLE) # Fruits.APPLE
print(Fruits.APPLE.name, Fruits.APPLE.value) # APPLE 1
print(repr(Fruits.APPLE)) # <Fruits.APPLE: 1>

months = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "July"]
for i, e in enumerate(months):
    print(i, ":", e)
"""
0 : Jan
1 : Feb
2 : Mar
3 : Apr
4 : May
5 : Jun
6 : July
"""
```
## python == 和is
- hashable
- \_\_hash\_\_
- \_\_eq\_\_
- id()

- is -> 比较id(object) object identity，比较是否拥有同一块内存空间
- \=\= -> 调用\_\_eq\_\_()方法

- \=\=操作符可以重载，is不可以

- string interning字符串驻留机制，当字符串比较小的时候，会保留其值的一个副本，当创建新的一样的字符串的时候直接指向该副本

## python模块的内置方法
\_\_name\_\_ 模块名字
\_\_doc\_\_  模块注释内容
\_\_file\_\_ 模块文件路径
\_\_package\_\_ 为了相对引用而设置的一个属性, 如果所在的文件是一个`package`的话, 它和`__name__`的值是一样的, 如果是子模块的话, 它的值就跟父模块一致
\_\_all\_\_ 指明有哪些模块会被import

## python class
- \_\_new\_\_ 和 \_\_init\_\_，先执行new后执行init，new第一参数是类，init第一参数是实例，可以不执行init但一定会执行new
- 

## python else
```
a = 100
for i in range(2, a):
	for j in range(2, i):
		if i%j == 0:
			break
	else:
		print("number {} is a prime number".format(i))
```
```
try:
except:
else:
finally:
避免在finally中使用break/return
```
## python classmethod & staticmethod
类方法classmethod一般是子类共有的属性
静态方法staticmethod


## python建议
- assert -> if \_\_debug\_\_
- 不推荐使用type
- 避免使用浮点数比较
- 可以在正常逻辑不可达达地方用assert语句来发现问题
- 充分利用lazy evaluation: &&, ||, 闭包
- 学会使用\_\_init\_\_.py
	- import xx from xx
	- \_\_all\_\_ = [xxx, sxxx, xsdds]
	- 尽量使用import a, 而不是 from a import xxx (sys.modules命名空间)

## Python数据类型整理
### 五大标准数据类型
- Numbers
	- 不可变数据类型
	- int/long/float/complex
	- 长整数
	- 小整型对象池：-5 ～ 257
- String
	- 不可变
- List
	- 可变
- Tuple
	- 不可变
- Set
	- 可变
- Dictionary
	- 可变


<!--stackedit_data:
eyJoaXN0b3J5IjpbOTQxMTIxODgyLC0xNDk2Mzc3MzMwLC0xND
kxMjc1NzQxLDg4MjE5MzE4OCwtNzA1MjY5MzUsMTUyMTk0NDQ2
MSwtODQ5ODE5NzQxLDExMzY4NjA3MSwtOTgwODI3MzAxLDY5Mz
k4OTkzNCwzMzI5NzY0NzcsLTkxMDc2MjU4NiwtMTM5NTY1NDI2
OSwtMTgxNDc0MzEwMCwtMjA1NDQyMzgwMywtMTM5NTk1ODA5XX
0=
-->