
```
docker inspect --format "{{ .Volumes }}" container
```


# 容器
## 背景
- 容器技术的兴起源于 **PaaS** 技术的普及
- Docker 公司发布对docker项目具有里程碑式意义
- docker项目通过“容器镜像”，解决了**应用打包**的根本难题
- 容器本身没有价值，有价值的是**容器编排**
- 容器是一个**单进程** ------ 只有一个进程是可控的

## 容器是一种沙盒技术
### 沙盒边界的定义
- 代码二进制+数据二进制 -> 程序 -> **代码的可执行镜像**
	-> **进程的静态表现**
- 程序运行 -> 内存里的数据+寄存器的值+堆栈指令+被打开的文件+各种设备的状态信息的**集合** 
	-> **进程的动态表现**
- 容器的核心技术：通过约束和修改进程的动态表现，从而为其创造出**边界**

- Cgroups用来约束进程的动态表现
- Namespace用来修改进程的视图(障眼法)

-> **容器只是运行在宿主机上的一个特殊进程**

### 隔离与限制的理解
进一步理解 **容器只是运行在宿主机上的一个特殊进程**
- 隔离
	- 容器的软件实体是依赖于宿主机的
	- Linux内核中有很多资源和对象是不能被namespace隔离化的，最典型的例子就是时间
	- 共享宿主机内核使得容器暴露出的攻击面大，一般不会把容器服务直接暴露在公网中
- 限制（cgroups）
	- 早期被cgroup限制的进程组也被称为容器 
	- cgroups可以做：
		- 资源限制
		- 进程优先级设置和审计
		- 进程挂起和恢复
	- cgroups给用户暴露出来的操作接口是通过文件系统

### 实验
#### Cgroups
1. 基本操作指示
	- 操作接口的文件系统位置: ```/sys/fs/cgroups```
	- 查看cgroup操作接口: ```mount -t cgroup```, 每个目录都是一个子系统
		```
		nina@nina-VirtualBox:~$ mount -t cgroup
		cgroup on /sys/fs/cgroup/systemd type cgroup (rw,nosuid,nodev,noexec,relatime,xattr,name=systemd)
		cgroup on /sys/fs/cgroup/net_cls,net_prio type cgroup (rw,nosuid,nodev,noexec,relatime,net_cls,net_prio)
		cgroup on /sys/fs/cgroup/devices type cgroup (rw,nosuid,nodev,noexec,relatime,devices)
		cgroup on /sys/fs/cgroup/cpu,cpuacct type cgroup (rw,nosuid,nodev,noexec,relatime,cpu,cpuacct)
		cgroup on /sys/fs/cgroup/blkio type cgroup (rw,nosuid,nodev,noexec,relatime,blkio)
		cgroup on /sys/fs/cgroup/cpuset type cgroup (rw,nosuid,nodev,noexec,relatime,cpuset)
		cgroup on /sys/fs/cgroup/hugetlb type cgroup (rw,nosuid,nodev,noexec,relatime,hugetlb)
		cgroup on /sys/fs/cgroup/perf_event type cgroup (rw,nosuid,nodev,noexec,relatime,perf_event)
		cgroup on /sys/fs/cgroup/memory type cgroup (rw,nosuid,nodev,noexec,relatime,memory)
		cgroup on /sys/fs/cgroup/pids type cgroup (rw,nosuid,nodev,noexec,relatime,pids)
		cgroup on /sys/fs/cgroup/freezer type cgroup (rw,nosuid,nodev,noexec,relatime,freezer)
		cgroup on /sys/fs/cgroup/rdma type cgroup (rw,nosuid,nodev,noexec,relatime,rdma)
		```
		
	- 查看每个资源可以被限制的方法: ```ls /sys/fs/cgroup/xxx```
		```
		nina@nina-VirtualBox:~$ ls /sys/fs/cgroup/memory
		cgroup.clone_children       memory.kmem.max_usage_in_bytes      memory.max_usage_in_bytes        memory.usage_in_bytes
		cgroup.event_control        memory.kmem.slabinfo                memory.move_charge_at_immigrate  memory.use_hierarchy
		cgroup.procs                memory.kmem.tcp.failcnt             memory.numa_stat                 notify_on_release
		cgroup.sane_behavior        memory.kmem.tcp.limit_in_bytes      memory.oom_control               release_agent
		memory.failcnt              memory.kmem.tcp.max_usage_in_bytes  memory.pressure_level            tasks
		memory.force_empty          memory.kmem.tcp.usage_in_bytes      memory.soft_limit_in_bytes
		memory.kmem.failcnt         memory.kmem.usage_in_bytes          memory.stat
		memory.kmem.limit_in_bytes  memory.limit_in_bytes               memory.swappiness
		```
	- ```/sys/fs/cgroup/cpu/cfs_period```和```/sys/fs/cgroup/cfs_quota```可以限制进程在长度为cfs_period的时间段内，只能被分配到总量为cfs_quota的cpu时间

2. 限制一个进程的资源
	- 创建一个死循环进程，不加以限制
	  创建进程
	  ```
	  nina@nina-VirtualBox:~$ while : ; do : ; done &
	  [1] 29498
	  ```
	  查看进程资源
	  ```
	  nina@nina-VirtualBox:~$ top
	  top - 17:13:16 up 13 min,  2 users,  load average: 0.84, 0.77, 0.57
	  任务: 159 total,   2 running, 122 sleeping,   0 stopped,   0 zombie
	  %Cpu(s): 99.6 us,  0.0 sy,  0.0 ni,  0.0 id,  0.0 wa,  0.0 hi,  0.4 si,  0.0 st
	  KiB Mem :  4039508 total,   823168 free,   449052 used,  2767288 buff/cache
	  KiB Swap:   483800 total,   483800 free,        0 used.  3301680 avail Mem
	  进程 USER      PR  NI    VIRT    RES    SHR � %CPU %MEM     TIME+ COMMAND
	  29498 nina      20   0   31412   2780   1340 R 99.3  0.1   1:26.09 bash
	  ```
	 - chu a
	  
<!--stackedit_data:
eyJoaXN0b3J5IjpbMTk4Nzc4MDgxMCw3MDIzOTAxOTAsMTc4Nj
U4MDk3XX0=
-->